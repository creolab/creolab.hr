---
id: 37915ef3-3094-4a49-b0fb-e842da9550c4
published: false
blueprint: article
title: 'Productivity Mac OS setup for PHP development (Laravel) using the Zed editor'
author:
  - f63eaccf-f416-499c-a19c-3fbfec4e4c77
alt_seo_noindex: false
alt_seo_nofollow: false
exclude_from_sitemap: false
updated_by: f63eaccf-f416-499c-a19c-3fbfec4e4c77
updated_at: 1755472082
topics:
  - development
  - zed
  - laravel
  - php
  - vim
  - mac-os
  - terminal
sitemap_priority: 0.8
featured_image: 37915ef3-3094-4a49-b0fb-e842da9550c4/featured_zed.jpg
---
This article is all about how I like to set up my environment for PHP development from scratch. These are just my personal preferences, but hey, try a few out and you might end up liking them too.


![/assets/desktop.jpg](/assets/desktop.jpg)

## Overview

Here's a list of topic we're gonna cover today, so pick what you're most interested in.

1. Brief hardware overview
2. Mac OS setup, application and packages
3. Productivity apps and setup
4. Development environment setup
5. Editor setup

## Hardware

My daily driver is a 14" MacBook Pro M4, usually hooked up to a 27" Dell U2719D monitor. For typing, I use the Lemokey L3, and for pointing at stuff angrily I use the Logitech G900. Since working in total silence feels like a horror movie, I always have music playing‚Äîusually through my Sony WH-1000XM5s.  

The MacBook is also plugged into a Scarlett 2i2 audio interface (sometimes for recording guitar, more often just looking cool), and my Audio Engine HD3 speakers run through it too.  

Basically, lots of cables.  

## Mac OS setup

Normally I have everything automated in my dotfiles, but just for the sake of this article I‚Äôll walk you through how I set things up‚Äîkeyboard shortcuts, workflows, app switching, all that jazz.  

If you‚Äôre curious, my dotfiles live on [GitHub](https://github.com/bstrahija/dotfile).  

Most apps, libraries, fonts, and packages are installed with Homebrew, so make sure you‚Äôve got that.  
![/assets/desktop_dev.jpg](/assets/desktop_dev.jpg)

## Applications

My must-have apps (aka: ‚Äúif they broke, I‚Äôd cry‚Äù):

- [Raycast](https://raycast.com/?via=boris) ‚Äî Swiss Army knife for the Mac
- [Flashspace](https://github.com/wojciech-kulik/FlashSpace) - because macOS Spaces are‚Ä¶ let‚Äôs be polite and say *not great*
- [Ghostty](https://ghostty.org/) - as my main terminal emulator
- [Github Desktop](https://github.com/apps/desktop) - GUI for when I don‚Äôt feel like being a terminal wizard
- [Herd](https://herd.laravel.com/) - Laravel dev environment
- [Ice](https://github.com/jordanbaird/Ice) - hides menubar icons (because clutter makes me itchy)  
- [Karabiner Elements](https://karabiner-elements.pqrs.org/) - keyboard remapping magic 
- [TablePlus](https://tableplus.com/) - database wrangling
- [Zed](https://zed.dev/) - current editor
- [Zen](https://zen-browser.app/)/Chrome - Zen for casual browsing, Chrome for dev. Keeps my tabs from fighting each other

There are more, but let‚Äôs stick to the productivity/dev stuff for now.  

## Karabiner Elements

First of all we need the "hyper key". I know you can do that in Raycast, but I had it for a while in Karabiner along with some other bindings, so I'm keeping it there. So I bound my caps-lock key to fire off `cmd+ctrl+shift+option` when held down, but when you just press it, it triggers escape (very usefull for vim mode).

This is how this looks like:

```json
{
    "manipulators": [
        {
            "description": "Hyperkey",
            "from": {
                "key_code": "caps_lock",
                "modifiers": { "optional": ["any"] }
            },
            "to": [
                {
                    "key_code": "left_shift",
                    "modifiers": ["left_command", "left_control", "left_option"]
                }
            ],
            "to_if_alone": [{ "key_code": "escape" }],
            "type": "basic"
        }
    ]
}
```

## Raycast

[Raycast](https://raycast.com/?via=boris) is like a command center for my Mac. I use it for window management, app switching, emojis (very important), docs search, clipboard history, and more. Pro tip: I‚Äôm still on the free version.  

The magic sauce is the ‚Äúhyper key‚Äù‚Äîa single key that fires off `cmd+ctrl+shift+option` all at once. I bound it to caps lock (finally, caps lock has a purpose). From now on I‚Äôll refer to it as ‚ú¶.  

So let's go into some of my [Raycast](https://raycast.com/?via=boris) settings. 

For example:  
- ‚ú¶+arrow keys = tile windows  
- ‚ú¶+enter = maximize  
- ‚ú¶+space = center the window  

Switching and launching apps with [Raycast](https://raycast.com/?via=boris) is where the real magic happens. Sure, you could hit your hotkey, type the app name, hit enter‚Ä¶ but who has time for all that? (That‚Äôs like walking when you know there‚Äôs a skateboard leaning against the wall.)

Instead, I bind my most-used apps to direct shortcuts. Think of it as muscle memory meets productivity hacking. If you‚Äôve ever messed around with Omarchy by DDH, the concept is pretty similar‚Äîyou press a key combo, and boom, the app‚Äôs in your face before your brain even finishes the thought.

Here‚Äôs how my bindings look:

- **‚ú¶ + a** - browser (Zen; closest to caps lock, so my pinky doesn‚Äôt have to do yoga üòâ)
- **‚ú¶ + e** - editor (Zed)
- **‚ú¶ + t** - terminal (Ghostty)
- **‚ú¶ + g** - git (Github desktop)
- **‚ú¶ + c** - Chrome
- **‚ú¶ + l** - Linear
- **‚ú¶ + n** - Notion
- **‚ú¶ + m** - Mail
- **‚ú¶ + s** - Slack
- **‚ú¶ + x** - Spotify
- **‚ú¶ + d** - TablePlus (database stuff)

Basically, it‚Äôs like I gave my caps lock key superpowers, and now it opens wormholes to whichever app I want.

<iframe width="100%" height="320" src="https://www.youtube.com/embed/iByhWN9v1MQ?si=vArSZpBe539uBon_" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

I do have a bunch more, but these are the most commonly used.

And that‚Äôs just scratching the surface. With extensions, [Raycast](https://raycast.com/?via=boris) can do *a lot*. If you‚Äôre still on Alfred, you might wanna give this a spin.  

## Flashspace

macOS Spaces are‚Ä¶ let‚Äôs just say, not their strongest feature. Slow animations, little customization. Enter [Flashspace](https://github.com/wojciech-kulik/FlashSpace).  

It lets me set up multiple spaces, name them, add icons, and bind shortcuts. Most importantly‚Äîit‚Äôs instant. No laggy animations. Just ‚ú¶+1/2/3/etc and I‚Äôm jumping between fully configured workspaces.  

![/assets/flashspace.jpg](/assets/flashspace.jpg)

## Ghostty

Ghostty is my terminal emulator of choice. It‚Äôs fast, customizable, and‚Äîlet‚Äôs be honest‚Äîthe icon is great.  

I use zsh (default on macOS) with [Starship](https://starship.rs/) for a slick prompt. I used to run [oh-my-zsh](https://ohmyz.sh/) but it started dragging its feet. Oh, and don‚Äôt forget to install a [nerd font](https://www.nerdfonts.com/) for proper icons.  

![/assets/terminal.jpg](/assets/terminal.jpg)

Theme of the month: Everforest. I rotate fonts/themes every 2‚Äì3 months just to keep things fresh.  

Here are some CLI tools I can‚Äôt live without:  

### zellij

I used **[tmux](https://github.com/tmux/tmux/wiki)** for a while, but **[zellij](https://zellij.dev/)** is more user-friendly. If you‚Äôve never heard of them: they‚Äôre terminal multiplexers. Think split panes/tabs, but inside any terminal.  

I use it to keep sessions running, switch between projects, open panes, and keep long-running commands alive.  

![/assets/zellij.jpg](/assets/zellij.jpg)

### zoxide

**[Zoxide](https://github.com/ajeetdsouza/zoxide)** is `cd` on steroids. It learns your directory habits and lets you jump around with partial matches.  

Let's say you have a Laravel project inside **~/Code/personal/my-awesome-laravel-project** and you wanna jump into that directory, you can just type the following from anywhere in your terminal:

```bash
cd awesome-laravel
```

Or you wanna go to the migrations:

```bash
cd awesome migrations
```

As long as you‚Äôve been there before, it‚Äôll find it. Honestly, I couldn‚Äôt work without it now.

### eza

eza replaces ls and makes directory listings‚Ä¶ not boring. It supports icons (with nerd fonts) and tree views that actually look good.

![/assets/eza.jpg](/assets/eza.jpg)

Keep in mind you need to have nerd font installed to display the icons in the list.

### Other tools worth mentioning

And here are some others I use:

- **atuin** - smarter shell history
- **bat** - cat, but cuter
- **fastfetch** - system info flex
- **fzf** - fuzzy finder supreme
- **mailpit** - must have for testing email
- **prettyping** - because life‚Äôs too short for ugly pings
- **ripgrep** - better grep
- **speedtest-cli** - internet speed test for the cli
- **xh** - alternative to curl


## Zed Code Editor

After months of VS Code (and trying Vim motions inside it), it just felt‚Ä¶ sluggish. I wrote about my setup in this [article](/vs-code-setup-with-vim-motions). I did share some tips and my settings for VS Code that I setup to make as perfect as I could.

Then I tried [Zed](https://zed.dev/). Everyone said Vim motions were smooth, and they weren‚Äôt lying. After a few days of tweaking settings, I went all in. Been using it exclusively for ~2 weeks now. No regrets.


![/assets/zed.jpg](/assets/zed.jpg)

### Settings

First of all, let's go over some settings I feel are a must (my preference). The I currently use is **Everforest**, the font is **MonaspiceKr Nerd Font"** and the icon theme is the **Bearded Icon Theme**.

I keep the project tree on the right, git panel + AI chat on the left. Autosuggest is hidden unless I summon it with a shortcut (otherwise it just gets annoying).


Full settings: [settings.json](https://github.com/bstrahija/dotfiles/blob/main/zed/settings.json)


### PHP LSP Settings

I run phpactor and phptools, plus PHPStan on Laravel projects. Setup is dead simple‚Äîenable LSPs and you‚Äôre good.

Dotfiles here if you‚Äôre curious: [dotfiles](https://github.com/bstrahija/dotfiles)

### Snippets

Haven‚Äôt ported them all yet, but my most-used snippets are here:
[snippets](https://github.com/bstrahija/dotfiles/tree/main/zed/snippets)

### Keymap and bindings

This is where things get serious. Or, as serious as one can get while arguing about which key should be pressed to escape **INSERT** mode.  

Step one: enable Vim mode in Zed. Congrats, you‚Äôre already halfway to being cooler than everyone else in your office.  

If you‚Äôve never tried Vim motions‚Äîdo it. You‚Äôll hate it at first, then suddenly one day your fingers will be flying like you‚Äôve unlocked a cheat code. If you *did* try them before and didn‚Äôt like them‚Ä¶ sorry, but you were wrong üòâ  

Learning the basics is easy: there are endless tutorials, a VS Code extension with training built in, and even games online to practice. (Yes, typing games for developers exist, and no, they won‚Äôt improve your WPM on Tinder.)  

Now, let‚Äôs talk about the **leader key**. Think of it as a ‚Äúwhat I really meant was‚Ä¶‚Äù key. In Vim, it‚Äôs a special prefix that makes your custom shortcuts possible. I bound mine to the **spacebar**‚Äîbecause hey, it‚Äôs the biggest, easiest-to-hit key on the keyboard. Might as well put it to work.  

Full keymap lives here: [keymap.json](https://github.com/bstrahija/dotfiles/blob/main/zed/keymap.json)  

But let‚Äôs go through some of the most useful bindings I‚Äôve added on top of Zed‚Äôs defaults.  

### Favorite and most used bindings

Again, to fully understand the keybinds, you need to understand that vim has multiple modes, the 3 most ones are **NORMAL**, **INSERT** and **VISUAL**, so we define out keybindigs in a conxets regarding which mode we are in.

Eg. when I wanna search for files in a project, I press **leader leaders**, meaning space 2 times. It's basically the same as **cmd+p** in VS Code.

Here are some of the bindings I have setup with my leader key:

```json
{
    "context": "Editor && vim_mode == normal && vim_operator == none && !VimWaiting",
    "bindings": {
        "space space": "file_finder::Toggle",
        "space e": "project_panel::ToggleFocus", // Focu on the file tree
    	"space /": "pane::DeploySearch",
      	"space p": "command_palette::Toggle", // All commands, same as : 
        "space r": "outline::Toggle", // Show list of functions, variables...	
        "space o": "pane::CloseOtherItems",
        "space s": "pane::SplitRight",
        "space S": "pane::SplitDown", 
        "space tab": "tab_switcher::Toggle", // Show open tabs
        "space d": "diagnostics::Deploy", // Show all errors
        "space g": "git_panel::ToggleFocus",
        "space a": "agent::ToggleFocus", // AI agent
    }
}
```

All of these work in NORMAL mode. Pretty self-explanatory once you start using them.

Now, escaping **INSERT** mode with the esc key is‚Ä¶ fine. But it‚Äôs way over there, like the keyboard‚Äôs no-man‚Äôs-land. Instead, I mapped **jj** and **jk** to exit **INSERT** mode. My pinky thanks me every day.

```json
{
    "context": "Editor && vim_mode == insert",
    "bindings": {
      "j k": "vim::NormalBefore",
      "j j": "vim::NormalBefore",
    }
},
```

For code navigation, I‚Äôve got this setup (basically, hit g for ‚Äúgo‚Äù):

```json
{
    "context": "Editor && vim_mode == normal && vim_operator == none && !VimWaiting",
    "bindings": {
        "g d": "editor::GoToDefinition",
        "g D": "editor::GoToDefinitionSplit",
        "g i": "editor::GoToImplementation",
        "g I": "editor::GoToImplementationSplit",
        "g t": "editor::GoToTypeDefinition",
        "g T": "editor::GoToTypeDefinitionSplit",
        "g r": "editor::FindAllReferences"
    }
}
```

I also keep some global shortcuts that work in any mode, like project switching and toggling docks:

```json
{
    "context": "Workspace",
    "bindings": {
        "alt-cmd-p": ["projects::OpenRecent", { "create_new_window": false }],
        "cmd-1": "workspace::ToggleRightDock",
        "cmd-2": "workspace::ToggleLeftDock",
        "cmd-3": "workspace::ToggleBottomDock",
        "cmd-r": "outline::Toggle"
    }
},
```

Eh, pressing **alt-cmd-p** show my recent projects. Thats how I switch between various projects. Actually this works so fast that it doesn't even make sent to have multiple windows open.

I mentioned before I have the AI auto suggestions disabled, and I use a keyboard shortcut. This looks something like this:

```json
{
    "context": "Editor && vim_mode == insert",
    "bindings": {
      "ctrl-x ctrl-o": "editor::ShowCompletions",
      "ctrl-x ctrl-a": "assistant::InlineAssist",
      "ctrl-x ctrl-c": "editor::ShowEditPrediction",
    }
},
```

Also I have **leader e** defined to switch between the editor and the file tree, so when focused on the file tree I need a way to do some file management, so I set this up like so:

```json
{
    "context": "ProjectPanel && not_editing",
    "bindings": {
      "a": "project_panel::NewFile",
      "A": "project_panel::NewDirectory",
      "p": "project_panel::Paste",
      "x": "project_panel::Cut",
      "s": "project_panel::Open",
      "c": "project_panel::Copy",
      "r": "project_panel::Rename",
      "d": "project_panel::Trash",
    }
}
```

This means when navigating through the file tree, you can simply press a single key and do the required action.

Finally, tab switching. Because yes, I‚Äôm still figuring out whether I prefer the Vim-style H/L navigation or just smashing tab/shift-tab like a gamer changing weapons:

```json
{
    "context": "Editor && vim_mode == normal && vim_operator == none && !VimWaiting",
    "bindings": {
        "tab": "pane::ActivateNextItem",
        "shift-tab": "pane::ActivatePreviousItem",
        "H": "pane::ActivatePreviousItem",
        "L": "pane::ActivateNextItem",
    }
}
```

Still experimenting, but either way, it beats reaching for the mouse like some kind of animal.